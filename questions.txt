1.  According to wikipedia, the header, stdint.h is a standard C library to write more portable code by providing a set of custom data type (typedefs) that specify exact- width integer types, together with defined minimum and maximum allowable values for each type.
2.  The typedef name intN_t defines that a signed integer with width N, no padding bits, and a two's complement representation. Thus, int32_t denotes a signed integer of width of exactly 32 bit. And for the typedef name uintN_t defines that a unsigned integer with width N. hence, uint8_t, uint32_t, uint16_t denotes an unsigned integer type with width of exactly 8 bits, 32 bits, 16 bits respectively. As a result, we can fill up the exact amount of space in a file which is good for things like bitmap header.
3.  BYTE = 1 byte = 8 bits, DWORD = 4 bytes = 32 bits, LONG = 4 bytes = 32 bits, WORD = 2 bytes = 16 bits.
4.  The first two bytes or first WORD of any bmp files are stored in bfType. The magic numbers in ASCII is BM (first B then M), in decimal 66 77 and in Hexadecimal it is 0x42 4d.
5.  bfSize is the size of bitmap file in bytes and biSize is the number of bytes required by the structure or the number of bytes in the info header (usually 40 bits for a bitmap). 
6.  biHeight is the height of bitmap in pixels. If biHeight is negative, the bitmap is a top-down DIB and its origin is the upper-left corner. biHeight being negative, a top-down DIB (Device Independent Bitmap), biCompression must be either BI_RGB or BI_BITFIELDS. Top-down DIBs cannot be compressed.
7.  biBitCount specifies the BMP's color-depth (bits per pixel) in BITMAPINFOHEADER. for example, if the biBitCount value is 0, it means it is of JPEG or PNG format. if the value (N= 1, 4, 8, 16, 24, 32), the bitmap has a maximum color of 2^N.
8.  fopen might return NULL if the pointer *inptr or *outptr does not find any file to the pointee to read or write in line 24 or 32 respectively. 
9.  The BITMAPFILEHEADER or BITMAPINFOHEADER is 1 struct. The third arguement of fread is always 1 because we are reading 1 struct at a time in our code. (struct are just like arrays but of different datatypes)
10. padding will be 3 beacause int padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4; implies if bi.biWidth = 3 and sizeof(RGBTRIPLE) = 3 (because RGB triple stores 8 bits or 1 byte for each colour which makes RGBTRIPLE 3 bytes), then int padding =  (4 - (3 * 3) % 4) % 4; or int padding =  (4 - 1) % 4; or int padding =  3.  
11. int fseek(FILE* fp, long int offset, int from_where); allows to change the location of the pointer. offset refers to how many bytes we waant to change the current position of the file pointer fp.  If we want to change the location of pointer fp from its current location we set from_where to SEEK_CUR. altogether, fseek moves to a specific location in a file. 
12. SEEK_CUR is the current location indicator in a file. the from_where arguement of fseek function is changed to SEEK_CUR to change the location of pointer to current position. 
